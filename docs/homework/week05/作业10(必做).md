# 作业10

**题目描述**：研究一下 JDBC 接口和数据库连接池，掌握它们的设计和用法：

* a. 使用 JDBC 原生接口，实现数据库的增删改查操作。

* b. 使用事务，PrepareStatement 方式，批处理方式，改进上述操作。

* c. 配置 Hikari 连接池，改进上述操作。

------

## 原生JDBC

数据库中创建一张账户表：

```mysql
CREATE DATABASE mydatabase;
USE mydatabase;
CREATE TABLE account (
    id INT (11) PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(20) NOT NULL,
    money INT DEFAULT NULL
);
INSERT INTO account VALUES (1,'zhangsan',1000);
INSERT INTO account VALUES (2,'lisi',1000);
```

创建插入和查询方法：

```java
public class UserService {
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        // mysql注册驱动
        Class.forName("com.mysql.cj.jdbc.Driver");
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String username = "root";
        String password = "513701";
        // 获取连接对象
        Connection conn = DriverManager.getConnection(url, username, password);
        if (conn != null) {
            System.out.println("Database connection success!");
        }
        return conn;
    }

    /**
     * 插入
     */
    public void save() {
        Connection conn = null;
        Statement stmt = null;
        try {
            conn = getConnection();
            conn.setAutoCommit(false);
            System.out.println("默认事务隔离级别" + conn.getTransactionIsolation());
            // 创建执行SQL语句的Statement对象
            stmt = conn.createStatement();
            // 创建并执行SQL语句
            stmt.execute("insert account values (3,'wang',2000)");
            System.out.println("Insert data success!");

            conn.commit();
        } catch (Exception e) {
            e.printStackTrace();
        } finally { // 释放资源
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (conn != null) {
                try {
                    conn.close();
                    System.out.println("Database connection terminated!");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * 查询
     */
    public void query() throws Exception {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            stmt = conn.createStatement();
            String query = "select * from account where username= 'wang'";
            rs = stmt.executeQuery(query);

            while (rs.next()) {
                int id = rs.getInt("id");
                String uername = rs.getString("username");
                String money = rs.getString("money");
                System.out.println("id: " + id + " name: " + uername + " money: " + money);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (rs != null) {
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if (stmt != null) {
                try {
                    stmt.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }

            if (conn != null) {
                try {
                    conn.close();
                    System.out.println("Database connection terminated!");
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```

测试方法：

```java
    @Test
    public void testSave() throws Exception {
        UserService service = new UserService();
        service.save();
    }

    @Test
    public void testQuery() throws Exception {
        UserService service = new UserService();
        service.query();
    }
```

分别执行结果：

```java
Database connection success!
默认事务隔离级别4
Insert data success!
Database connection terminated!
    
Database connection success!
id: 3 name: wang money: 2000
Database connection terminated!
```

## 基于注解实现事务管理

还是采用同一张表，目前其有三条数据：

```sql
id: 1 name: zhangsan money: 1000
id: 2 name: lisi money: 1000
id: 3 name: wang money: 2000
```

下面实现一个功能——通过name对money进行增减（即存款取款和用户间转账），这里就需要进行事务管理保证操作的原子性、一致性、隔离性、持久性；同时，我们使用JdbcTemplate来防止SQL注入。、

### （1）创建DAO层接口实现类

```java
public interface AccountDao {
    /**
     * 取款
     */
    public void out(String outUser, int money);

    /**
     * 存款
     */
    public void in(String inUser, int money);
}
```

```java
public class AccountDaoImpl implements AccountDao {
    private JdbcTemplate jdbcTemplate;

    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public void out(String outUser, int money) {
        this.jdbcTemplate.update("update account set money = money - ? "
                + "where username = ?", money, outUser);
    }

    @Override
    public void in(String inUser, int money) {
        this.jdbcTemplate.update("update account set money = money + ? "
                + "where username = ?", money, inUser);
    }
}
```

### （2）创建Service层接口实现类

```java
public interface AccountService {
    /**
     * 转账
     */
    void transfer(String outUser, String inUser, int money);
}
```

```java
public class AccountServiceImpl implements AccountService {
    private AccountDao accountDao;

    public void setAccountDao(AccountDao accountDao) {
        this.accountDao = accountDao;
    }

    @Override
    public void transfer(String outUser, String inUser, int money) {
        this.accountDao.out(outUser, money);
        this.accountDao.in(inUser, money);
    }
}
```

### （3）创建 Spring 配置文件bean.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/tx
            http://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 配置数据源，读取properties文件信息 -->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"></property>
        <property name="url" value="jdbc:mysql://localhost:3306/mydatabase"></property>
        <property name="username" value="root"></property>
        <property name="password" value="513701"></property>
    </bean>
    <!-- 配置jdbc模板 -->
    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
        <property name="dataSource" ref="dataSource"/>
    </bean>
    <!-- 配置dao -->
    <bean id="accountDao" class="com.zgakii.springboot.jdbc.dao.impl.AccountDaoImpl">
        <property name="jdbcTemplate" ref="jdbcTemplate"/>
    </bean>
    <!-- 配置service -->
    <bean id="accountService" class="com.zgakii.springboot.jdbc.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"/>
    </bean>

    <!-- 事务管理器，依赖于数据源 -->
    <bean id="txManager"
          class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource" />
    </bean>
    <!-- 注册事务管理驱动 -->
    <tx:annotation-driven transaction-manager="txManager"/>
</beans>
```

### （4）添加 @Transactional 注解‘

AccountServiceImpl中添加 @Transactional 注解及参数：

```java
@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)
```

### （5）创建测试方法

```java
    @Test
    void testAnnotation() {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");
        AccountService accountService = (AccountService) applicationContext
                .getBean("accountService");
        accountService.transfer("zhangsan", "lisi", 100);
        accountService.transfer("wang", "lisi", 200);
    }
```

运行testAnnotation() 后可以再运行一下testQuery()方法：

```java
id: 1 name: zhangsan money: 900
id: 2 name: lisi money: 1300
id: 3 name: wang money: 1800
```

## HikariCP连接池

### （1）引入HikariCP连接池

```xml
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
            <exclusions>
                <exclusion>
                    <groupId>org.apache.tomcat</groupId>
                    <artifactId>tomcat-jdbc</artifactId>
                </exclusion>
            </exclusions>
        </dependency>
        
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </dependency>        
```

### （2）修改bean.xml配置文件

```xml
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/mydatabase"/>
        <property name="username" value="root"/>
        <property name="password" value="513701"/>
        <!-- 等待连接池分配连接的最大时长(毫秒), 超过这个时长还没可用的连接则发生SQLException, 缺省:30秒 -->
        <property name="connectionTimeout" value="30000"/>
        <!-- 一个连接idle状态的最大时长(毫秒), 超时则被释放(retired), 缺省:10分钟 -->
        <property name="idleTimeout" value="600000"/>
        <!-- 一个连接的生命时长(毫秒), 超时而且没被使用则被释放, 缺省:30分钟, 建议设置比数据库超时时长少30秒, 参考MySQL wait_timeout参数(show variables like '%timeout%';) -->
        <property name="maxLifetime" value="1800000"/>
        <!-- 最小空闲数 为了最大限度地提高性能和响应速度，我们建议不要设置此值 -->
        <!--<property name="minimumIdle" value="5" />-->
        <!-- 连接池中允许的最大连接数。缺省值: 10; 推荐的公式: ((core_count * 2) + effective_spindle_count) -->
        <property name="maximumPoolSize" value="10"/>
        <!-- 连接只读数据库时配置为true, 保证安全 -->
        <property name="readOnly" value="false"/>
    </bean>
```

### （3）测试

```java
    @Test
    void testAnnotation() {
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml");
        AccountService accountService = (AccountService) applicationContext
                .getBean("accountService");
        accountService.transfer("zhangsan", "lisi", 100);
        accountService.transfer("wang", "lisi", 200);
    }
```

运行testAnnotation() 后可以再运行一下testQuery()方法：

```java
id: 1 name: zhangsan money: 800
id: 2 name: lisi money: 1600
id: 3 name: wang money: 1600
```

## 