# 作业三

**题目描述**：列举常用的并发操作API和工具类，简单分析其使用场景和优缺点。

------

## 线程生命周期相关

Java线程在运行的生命周期中可能处于如下6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态。

| 线程状态      | 说明                                                         |
| :------------ | ------------------------------------------------------------ |
| NEW           | 初始状态，线程刚被创建，但是并未启动（还未调用start方法）。  |
| RUNNABLE      | 运行状态，JAVA线程将操作系统中的就绪（READY）和运行（RUNNING）两种状态笼统地称为“运行中”。 |
| BLOCKED       | 阻塞状态，表示线程阻塞于锁。                                 |
| WAITING       | 等待状态，表示该线程无限期等待另一个线程执行一个特别的动作。 |
| TIMED_WAITING | 超时等待状态，不同于WAITING的是，它可以在指定时间自动返回。  |
| TERMINATED    | 终止状态，表示当前状态已经执行完毕。                         |

线程在自身的生命周期中，并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换。

<div align="center"> <img src="..\..\images\20200929220833538.png" width="600px"></div>

`java.lang.Thread`中重要属性/方法：

| 重要属性/方法                            | 说明                                   |
| :--------------------------------------- | -------------------------------------- |
| `volatile String name;`                  | 线程名称-诊断分析使用。                |
| `boolean daemon = false;`                | 后台守护线程标志 – 决定JVM优雅关闭     |
| `Runnable target;`                       | 任务(只能通过构造函数传入)             |
| `synchronized void start()`              | 【协作】启动新线程并自动执行           |
| `void join()`                            | 【协作】等待某个线程执行完毕（来汇合） |
| `static native Thread currentThread(); ` | 静态方法: 获取当前线程信息             |
| `static native void sleep(long millis);` | 静态方法: 线程睡眠并让出CPU时间片      |
| `static native void yield()`             | 静态方法：线程进入READY就绪状态        |
| `void interrupt()`                       | 中断线程                               |

`java.lang.Object`中重要方法：

| Object中方法                          | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| `void wait() `                        | 放弃锁+等待0ms+尝试获取锁;                                   |
| `void wait(long timeout, int nanos) ` | 放弃锁 + wait + 到时间自动唤醒/中途唤醒 (精度: nanos>0则 timeout++) |
| `native void wait(long timeout); `    | 放弃锁+ wait + 到时间自动唤醒/中途被唤醒 (唤醒之后需要自动获取锁) |
| `native void notify(); `              | 发送信号通知1个等待线程                                      |
| `native void notifyAll(); `           | 发送信号通知所有等待线程                                     |

` java.util.concurrent.locks.LockSupport`中重要方法：

| LockSupport中方法             | 说明                       |
| ----------------------------- | -------------------------- |
| `void park() `                | 放弃锁+等待0ms+尝试获取锁; |
| `void unpark(Thread thread) ` | 发送信号通知1个等待线程    |

## 线程池相关





## 线程安全关键字

### synchronized

synchronized采用**互斥同步**（Mutual Exclusion & Synchnronization）的方式，让多个线程并发访问共享数据时，保证共享数据在同一时刻只被一个（或一些，使用信号量的时候）线程使用。互斥是实现同步的一种手段，临界区、互斥量和信号量都是主要的互斥实现方式。

<div align="center"> <img src="..\..\images\20201025123258136.png" width="700px"></div>

JDK 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。所以，目前锁一共有4种状态，级别从低到高依次是：**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**，这几个状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

四种锁状态对应的的Mark Word内容描述如下：

<div align="center"> <img src="..\..\images\20201027235703700.png" width="600px"></div>

在64位虚拟机下，Mark Word在不同锁状态存储结构如下：

<div align="center"> <img src="..\..\images\20201026011946370.png" width="600px"></div>

这4种锁并不是相互替代的关系，它们只是在不同场景下的不同选择。

| 锁       | 优点                                                         | 缺点                                                | 适用场景                                 |
| -------- | ------------------------------------------------------------ | --------------------------------------------------- | ---------------------------------------- |
| 偏向锁   | 加锁和解锁不需要额外消耗，<br>和执行非同步方法相比仅仅存在纳秒级的差距。 | 线程间存在锁竞争，<br>会带来额外的锁撤销的消耗。    | 适用于只有一个线程访问同步块场景。       |
| 轻量级锁 | 竞争的线程不会阻塞，<br>提高了线程的响应速度。               | 如果始终得不到锁竞争的线程，<br>使用自旋会消耗CPU。 | 追求响应速度，<br>同步块执行速度非常快。 |
| 重量级锁 | 线程竞争不会使用自旋，<br>不会消耗CPU。                      | 线程阻塞，响应时间缓慢。                            | 追求吞吐量，<br>同步块执行时间较长。     |

### volatile

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

（1）**保证了不同线程对这个变量进行操作时的可见性**，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

（2）**禁止进行指令重排序**。

volatile（表示易变关键字的意思），它要求线程必须从主内存中获取变量的值，线程操作 volatile 变量都是直接操作主内存。它遵循`happen-before`规则来禁止指令重排。

### final

| final 定义类型    | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| final class XXX   | 不允许继承                                                   |
| final 方法        | 不允许 Override                                              |
| final 局部变量    | 不允许修改                                                   |
| final 实例属性    | 构造函数/初始化块/之后不允许变更；<br/>只能赋值一次<br/>**安全发布**: 构造函数结束返回时，final 域最新的值被保 证对其他线程可见 |
| final static 属性 | `<clinit>`静态块执行后不允许变更；只能赋值一次               |

## Lock锁机制类

### Lock

### ReentrantLock

### ReadWriteLock

> **LockSupport**重要的方法`park()/unpark()`上面已经说明。

## Atomic原子类

| Atomic类型         | 类名                                                         |
| ------------------ | ------------------------------------------------------------ |
| 基本类型           | AtomicInteger：整型原子类<br>AtomicLong：长整型原子类<br/>AtomicBoolean ：布尔型原子类 |
| 数组类型           | AtomicIntegerArray：整型数组原子类<br/>AtomicLongArray：长整型数组原子类<br/>AtomicReferenceArray ：引用类型数组原子类 |
| 引用类型           | AtomicReference：引用类型原子类 <br/>AtomicMarkableReference：原子更新带有标记的引用类型<br/>AtomicStampedReference ：原子更新带有版本号的引用类型 |
| 对象的属性修改类型 | AtomicIntegerFieldUpdater：原子更新整型字段的更新器<br/>AtomicLongFieldUpdater：原子更新长整型字段的更新器 <br/>AtomicReferenceFieldUpdater：原子更新引用类型里的字段 |
| 原子累加器         | DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder   |

> **核心实现原理**：
>
> volatile 保证读写操作都可见（注意不保证原子）；
>
> 使用 CAS 指令，作为乐观锁实现，通过自旋重试保证写入

例如`AtomicInteger`类常用方法有：

| 方法                                            | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `get()`                                         | 获取当前的值                                                 |
| `getAndSet(int newValue)`                       | 获取当前的值，并设置新的值                                   |
| `getAndIncrement()`                             | 获取当前的值，并自增                                         |
| `getAndDecrement()`                             | 获取当前的值，并自减                                         |
| `getAndAdd(int delta)`                          | 获取当前的值，并加上预期的值                                 |
| `boolean compareAndSet(int expect, int update)` | 如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update） |
| `lazySet(int newValue)`                         | 最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 |

## 常见并发工具类

### Semaphore(信号量)

### CountDownLatch (倒计时器)

### CyclicBarrier(循环栅栏)

## 常见并发容器

### ConcurrentHashMap

### CopyOnWriteArrayList

### ConcurrentLinkedQueue

### BlockingQueue

### ConcurrentSkipListMap