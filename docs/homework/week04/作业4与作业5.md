# 作业4

**题目描述**：什么是并发? 什么是高并发? 实现高并发高可用系统需要考虑哪些因素，对于这些你是怎么理解的?

------

**并发(Concurrency)**

并发，经常与并行的概念一起提及，通俗地讲：

* 并发，指的是两个或多个任务在**同一时间段**内发生；
* 并行，指的是两个或多个任务在**同一时刻**发生（即同时发生）。

<div align="center"> <img src="..\..\images\20200928145847985.png" width="600px"></div>

上图很好地诠释了并发与并行，并行的任务是同时发生的，而并发种任务是交替执行的，一会儿执行任务1，一会儿执行任务2，系统会不停地在多个任务间切换。如果只有单核CPU，程序是无法真正实现并行的；然而就算是串行并发，对于外部观察者而言，也还是会有多个任务并行执行的错觉，这就是所谓的`微观串行，宏观并行`。

**高并发(High Concurrency)**

高并发就意味着高流量，它通常是指系统运行过程中“短时间内遇到大量操作请求”的情况，例如双十一零点剁手和12306抢票的情况。

高并发常见指标：

* 响应时间(Response Time)：系统对请求做出响应的时间。
* 吞吐量(Throughput)：单位时间内处理的请求数量。
* 每秒查询率 QPS(Query Per Second)：每秒响应请求数。
* 并发用户数(Concurrent Users)：同时承载正常使用系统功能的用户数量。

**如何实现高并发系统**

如果把高并发比作洪水，高并发系统设计关键所在就是如何巧妙地”抵御洪水“。通常有以下三种的方案：

（1）**横向扩展(Scale-out)**：即分而治之，采用分布式部署的方式把流量分流开，每个服务器一起承担部分并发和流量。

（2）**缓存**：加缓存用于缓解高并发对系统造成的冲击。就比如“拓宽河道”的方式减缓洪水的流动。

（3）**异步处理**：某些场景下，未处理完成之前可以让请求先返回，在数据准备好之后再通知请求方，这样可在单位时间内处理更多的请求。

当然，并不是说任何高并发系统都要用上以上三个方法，高并发系统的演进应该是循序渐进，以解决系统中存在的问题为目的和驱动力的。

**高并发系统的设计目标**

高并发系统的设计有三大设计目标：**高性能、高可用(High Availability，HA)、可扩展**。

性能反应了系统的使用体验，响应一万次请求的系统，响应时间是毫秒级或是秒级来来的体验是有天壤之别的；而可用性表示系统可以正常服务的时间，响应一万次请求的系统，全年无故障和时常宕机的体验天差地别；扩展性也是很重要的，例如无懈可击的微博系统也会在明显离婚等无聊绯闻事件中出现问题，正是良好的可扩展性，使其能在短时间内迅速完成扩容，更加平稳地承担峰值流量。

**高并发的架构模式**

分层架构是软件工程中常见的设计方式，例如MVC(Model-View-Controller)分层架构，把系统分为Model（模型），View（视图）和 Controller（控制器）三个层次；另外一种常见的分层方式是将整体架构分为表现层、逻辑层和数据访问层； TCP/IP 协议也是把网络简化成了四层，即链路层、网络层、传输层和应用层。

这是因为分层的设计可以简化系统设计，同时实现高可用与易于横向扩展。



# 作业5

**题目描述**：还有哪些跟并发类似 / 有关的场景和问题，有哪些可以借鉴的解决办法。

------

并发类似 / 有关的场景太多太多，这里简易描述一下秒杀系统。从双十一购物到春节抢红包，再到 12306 抢火车票，“秒杀”的场景处处可见。**秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统**。

秒杀主要解决两个问题，一个是并发读，一个是并发写。而要想打造并维护一个超大流量并发读写、高性能、高可用的系统，那么就得保证用户请求的**数据尽量少（减少cpu消耗）、请求数尽量少、路径尽量短（减少节点消耗）、依赖尽量少（减少加载时间）**，并且不要有单点（要有备份）。

下面以淘宝早期秒杀系统架构的演进为主线，梳理一下啊不同的请求体量下秒杀系统架构。

第一个版本的秒杀系统：商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。但随着请求量的加大（比如从 1w/s 到了 10w/s 的量级），这个简单的架构很快就遇到了瓶颈。

第二版本的秒杀系统：秒杀系统成为了一个独立的新系统，另外核心的一些数据放到了缓存（Cache）中，其他的关联系统也都以独立集群的方式进行部署。改进如下：

* 把秒杀系统独立出来单独打造一个系统，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；

* 在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；

* 将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；

* 增加秒杀答题，防止有秒杀器抢单。

此时的系统架构变成了下图这个样子。

<div align="center"> <img src="..\..\images\秒杀1.jfif" width="600px"></div>

然而这个架构仍然支持不了超过 100w/s 的请求量。

最终版本的秒杀系统：对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而只需要向服务端请求很少的动态数据；最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署等等。改进如下：

* 对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；

* 在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。

* 增加系统限流保护，防止最坏情况发生。

经过这些优化，系统架构变成了下图中的样子。

<div align="center"> <img src="..\..\images\秒杀2.jfif" width="800px"></div>

从前面的几次升级来看，其实越到后面需要定制的地方越多，也就是越“不通用”。例如，把秒杀商品缓存在每台机器的内存中，这种方式显然不适合太多的商品同时进行秒杀的情况，因为单机的内存始终有限。所以要取得极致的性能，就要在其他地方（比如，通用性、易用性、成本等方面）有所牺牲。